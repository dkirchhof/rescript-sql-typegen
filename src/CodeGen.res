module Column = {
  type t =
    | Int(string)
    | OptionalInt(string)

    | Real(string)
    | OptionalReal(string)

    | Text(string)
    | OptionalText(string)

    | Blob(string)
    | OptionalBlob(string)

  let toTypeString = column =>
    switch column {
    | Int(name) => `${name}: int`
    | OptionalInt(name) => `${name}: option<int>`
    | Real(name) => `${name}: float`
    | OptionalReal(name) => `${name}: option<float>`
    | Text(name) => `${name}: string`
    | OptionalText(name) => `${name}: option<string>`
    | Blob(name) => `${name}: string`
    | OptionalBlob(name) => `${name}: option<string>`
    }

  let toOptionalTypeString = column =>
    switch column {
    | Int(name) => `${name}: option<int>`
    | OptionalInt(name) => `${name}: option<int>`
    | Real(name) => `${name}: option<float>`
    | OptionalReal(name) => `${name}: option<float>`
    | Text(name) => `${name}: option<string>`
    | OptionalText(name) => `${name}: option<string>`
    | Blob(name) => `${name}: option<string>`
    | OptionalBlob(name) => `${name}: option<string>`
    }

  let toGenericColumnTypeString = column =>
    switch column {
    | Int(name) => `${name}: Column.t<int>`
    | OptionalInt(name) => `${name}: Column.t<option<int>>`
    | Real(name) => `${name}: Column.t<float>`
    | OptionalReal(name) => `${name}: Column.t<option<float>>`
    | Text(name) => `${name}: Column.t<string>`
    | OptionalText(name) => `${name}: Column.t<option<string>>`
    | Blob(name) => `${name}: Column.t<string>`
    | OptionalBlob(name) => `${name}: Column.t<option<string>>`
    }
}

type table = {
  name: string,
  columns: array<Column.t>,
}

/* type from = From(table, string) */
type join = InnerJoin(table, string) | LeftJoin(table, string)

module From = {
  type t = From(table, string)

  let toGenericTableTypeString = from =>
    switch from {
    | From(_, alias) => `${alias}: Table.t`
    }
}

module Join = {
}

let indent = (str, indentation) => Js.String2.repeat(" ", indentation) ++ str

let wrapInType = (rows, typeName) =>
  Belt.Array.concatMany([[`type ${typeName} = {`], rows->Js.Array2.map(indent(_, 2)), [`}`]])

let wrapInModule = (rows, moduleName) =>
  Belt.Array.concatMany([[`module ${moduleName} = {`], rows->Js.Array2.map(indent(_, 2)), [`}`]])

let makeModuleName = tableName => {
  let firstUpper = tableName->Js.String2.get(0)->Js.String2.toUpperCase
  let rest = tableName->Js.String2.substringToEnd(~from=1)

  `${firstUpper}${rest}Table`
}

let makeColumnsType = (typeName, columns, columnToTypeString) => {
  columns->Js.Array2.map(c => columnToTypeString(c) ++ ",")->wrapInType(typeName)
}

let makeTableModule = table => {
  let moduleName = makeModuleName(table.name)

  let tableName = `let tableName = "${table.name}"`

  let normalProjectables = makeColumnsType("projectables", table.columns, Column.toTypeString)

  let optionalProjectables = makeColumnsType(
    "optionalProjectables",
    table.columns,
    Column.toOptionalTypeString,
  )

  let selectables = makeColumnsType("selectables", table.columns, Column.toGenericColumnTypeString)

  "// generated by CodeGen.makeTableModule\n" ++
  Belt.Array.concatMany([
    [tableName],
    [""],
    normalProjectables,
    [""],
    optionalProjectables,
    [""],
    selectables,
  ])
  ->wrapInModule(moduleName)
  ->Js.Array2.joinWith("\n")
}

let makeTablesType = (from, joins) => {
  let from = From.toGenericTableTypeString(from) ++ ","

  [from]->wrapInType("tables")
}

let makeQueryModule = (moduleName, from: From.t, joins) => {
  let tables = makeTablesType(from, joins)

  "// generated by CodeGen.makeQueryModule\n" ++
  Belt.Array.concatMany([["open Query"], [""], tables])
  ->wrapInModule(moduleName)
  ->Js.Array2.joinWith("\n")
}
